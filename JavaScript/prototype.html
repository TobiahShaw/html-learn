<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>prototype</title>
</head>
<body>

<h2>JavaScript prototype</h2>
<p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。</p>

<h3>prototype 继承</h3>
<p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法：</p>
<ul>
  <li>Date 对象从 Date.prototype 继承。</li>
  <li>Array 对象从 Array.prototype 继承。</li>
  <li>Person 对象从 Person.prototype 继承。</li>
</ul>
<p>所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p>

<P>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。Date 对象, Array 对象, 以及 Person 对象从 Object.prototype 继承。</P>

<h4>添加属性和方法</h4>
<p>有的时候我们想要在所有已经存在的对象添加新的属性或方法。另外，有时候我们想要在对象的构造函数中添加属性或方法。使用 prototype 属性就可以给对象的构造函数添加新的属性：</p>
<p>Person.prototype.nationality = "English";</p>

<p id="demo"></p>
<p id="demo1"></p>
<p id="demo2"></p>

<script>
// 对象的构造器（constructor）
function Person(first, last, age, eye) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eye;
}

// 我们也知道在一个已存在的对象构造器中是不能添加新的属性的：
Person.nationality = "English";

var myFather = new Person("John", "Doe", 50, "blue");
var myMother = new Person("Sally", "Rally", 48, "green");

document.getElementById("demo").innerHTML =
"我的父亲年龄是 " + myFather.age + "。我的母亲年龄是 " + myMother.age; 

document.getElementById("demo1").innerHTML =
"我父亲的国籍是 " + myFather.nationality; 

// 添加属性和方法
Person.prototype.nationality = "English";

Person.prototype.name = function() {
  return this.firstName + " " + this.lastName;
};

document.getElementById("demo2").innerHTML =
"我父亲的国籍是 " + myFather.nationality + ", 姓名是：" + myFather.name();
</script>

</body>
</html>